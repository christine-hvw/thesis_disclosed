---
title: "Exploratory Analyses"
author: "Christine Hedde - von Westernhagen"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(here)
library(tidyverse)
library(muxViz)
library(ggplot2)
library(ggraph)
library(igraph)
library(rgl)      # output 3d plots
library(tidytext) # ordering factors within facets
library(ggsankey) # sankey diagrams
```

# Data prep

```{r}
nodes <- read.csv(here("dummy_data/popnet_nodelist.csv"))
edges <- read.csv(here("dummy_data/popnet_edgelist.csv"))
```

```{r}
# types of edges
edges %>% 
  count(edgetype) %>% 
  arrange(desc(n))

# number of nodes
length(unique(c(edges$source, edges$target)))

# missing nodes
nodes[!nodes$node_id %in%  unique(c(edges$source, edges$target)),]
```

**Network sampling**

Example code if sampling is necessary.

```{r}
child_edges <- edges[edges$edgetype == "child",]

child_nodes <-  child_edges["source"]

keep_relations <- c("child", "parent", "sibling")

# sampling
sample_frac <- 0.3
pop_size <- nrow(child_nodes)

set.seed(789)
child_sample_idx <- sample(x = 1:pop_size, size = sample_frac * pop_size, replace = FALSE)

child_sample_ids <- child_nodes[child_sample_idx,]

# subset edge data to sampled children in specified relations
egdes_sample <- edges[(edges$source %in% child_sample_ids | edges$target %in% child_sample_ids) &
                        (edges$edgetype %in% keep_relations),]
```

Here, proceed with full data set.

```{r}
# Make single-layer network
g_all <- graph_from_data_frame(d = edges[, c("source", "target")],
                               vertices = nodes$node_id)
```

```{r}
# Make multi-layer network
groups <- unique(edges$edgetype)
layers <- 5 # (after collapsing family categories)
obs <- nrow(nodes)

node_tensor <- list()
g_list <- list()

for (g in groups) {
  graph <- graph_from_data_frame(d = edges[edges$edgetype == g, c("source", "target")],
                                 # include ALL vertices
                                 vertices = nodes$node_id)
  g_list[[g]] <- graph
  node_tensor[[g]] <- as_adjacency_matrix(graph)
}


# collapse corresponding categories into "family"
family <-  c('aunt / uncle', 'neighbor', 'cousin', 'mother / father-in-law', 'sibling',  'grandchild', 'grandparent',  'niece / nephew', 'parent', 'sister / brother-in-law',  'child', 'daughter / son-in-law')

graph_fam <- graph_from_data_frame(d = edges[edges$edgetype %in% family, c("source", "target")],
                                   # include ALL vertices
                                   vertices = nodes$node_id)
g_list[["family"]] <- graph_fam
node_tensor[["family"]] <- as_adjacency_matrix(graph_fam)

# remove subcategories of family from graph
g_list <- g_list[!names(g_list) %in% family]
node_tensor <- node_tensor[!names(node_tensor) %in% family]

# Define layer tensor
layer_tensor <- Matrix(1, 5, 5, sparse = TRUE, doDiag = FALSE)
diag(layer_tensor) <- FALSE

# Build supra-adjacency matrix
M <- BuildSupraAdjacencyMatrixFromEdgeColoredMatrices(node_tensor, layer_tensor, layers, obs)
```

# Explore multi-layer network

```{r, fig.height=7, fig.width=7}
#rotate <- function(mat) t(mat[nrow(mat):1, ,drop = FALSE])

#M_flip <- rotate(as.matrix(M))

# image(t(M_flip),
#       axes = FALSE)

heatmap(as.matrix(M), Rowv = NA, Colv = NA, useRaster = TRUE,
        col = hcl.colors(100), revC = TRUE,
        labRow = rep(1:nrow(nodes), layers), labCol = rep(1:nrow(nodes), layers))
```

```{r}
lay <- layoutMultiplex(g_list, layout = "comp", box = TRUE)

plot_multiplex3D(g_list,
  layer.layout = lay, layer.colors = c(2:6),
  layer.shift.x = 0.5, layer.space = 2,
  layer.scale = 2.2, layer.alpha = rep(.2, length(g_list)),
  layer.labels = names(g_list), layer.labels.cex = 1,
  node.size.values = 6,
  FOV = 0
)

snapshot3d("3dplot_dummy.png", fmt = "png", width = 1024, height = 1024)

knitr::include_graphics("3dplot_dummy.png")
```

# Explore multi vs. single-layer centralities

```{r, fig.width=4, fig.height=5, warning=FALSE}

plot_centrality_ranking <- function(type, single, multi, node_ids) {
  
  df <- data.frame("single" = single, "multi" = multi) %>% 
    mutate(id = as.factor(node_ids)) %>% 
    pivot_longer(cols = -id, names_to = "layers", values_to = type) %>% 
    group_by(layers) %>% 
    mutate(rank = rank(desc(.data[[type]]), ties.method = "min")) %>% 
    ungroup()
  
  top20_dat <- df %>% 
    arrange(layers, rank) %>% 
    group_by(layers) %>% 
    mutate(top20 = ifelse(row_number() %in% c(1:20), as.character(id), NA)) %>% 
    ungroup() %>% 
    mutate(top20 = ifelse(id %in% top20, TRUE, NA)) %>% 
    filter(top20 == TRUE) %>% 
    select(-.data[[type]]) %>% 
    pivot_wider(values_from = c("rank"), names_from = layers)

  sankey_dat <- top20_dat %>% 
    make_long("single", "multi")
  
  ggplot(sankey_dat, aes(x = x, next_x = next_x, node = node, next_node = next_node,
                         fill = node, label = node)) +
    geom_sankey(flow.alpha = .6) +
    geom_sankey_text(size = 3) +
    theme_sankey() +
    scale_fill_viridis_b() +
    theme(legend.position = "none")
  
}

# Degree
deg_single <- degree(g_all)
deg_mult <- c(GetMultiDegree(M, layers, obs, isDirected = FALSE))

plot_centrality_ranking("degree", deg_single, deg_mult, nodes$node_id)

# Eigenvector
eig_single <- eigen_centrality(g_all)$vector
eig_mult <- c(GetMultiEigenvectorCentrality(M, layers, obs))

plot_centrality_ranking("eigenvector", eig_single, eig_mult, nodes$node_id)

# k-core
# deg_single <- degree(g_all)
# deg_mult <- c(GetMultiDegree(M, layers, obs, isDirected = F))
# 
# plot_centrality_ranking("degree", deg_single, deg_mult, nodes$node_id)

# PageRank
pr_single <- page_rank(g_all)$vector
pr_mult <- c(GetMultiPageRankCentrality(M, layers, obs))

plot_centrality_ranking("pagerank", pr_single, pr_mult, nodes$node_id)

```
